// Code generated by protoc-gen-go. DO NOT EDIT.
// source: orderer/configuration.proto

package orderer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ConsensusType struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
}

func (m *ConsensusType) Reset()                    { *m = ConsensusType{} }
func (m *ConsensusType) String() string            { return proto.CompactTextString(m) }
func (*ConsensusType) ProtoMessage()               {}
func (*ConsensusType) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *ConsensusType) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type BatchSize struct {
	// Simply specified as number of messages for now, in the future
	// we may want to allow this to be specified by size in bytes
	MaxMessageCount uint32 `protobuf:"varint,1,opt,name=max_message_count,json=maxMessageCount" json:"max_message_count,omitempty"`
	// The byte count of the serialized messages in a batch cannot
	// exceed this value.
	AbsoluteMaxBytes uint32 `protobuf:"varint,2,opt,name=absolute_max_bytes,json=absoluteMaxBytes" json:"absolute_max_bytes,omitempty"`
	// The byte count of the serialized messages in a batch should not
	// exceed this value.
	PreferredMaxBytes uint32 `protobuf:"varint,3,opt,name=preferred_max_bytes,json=preferredMaxBytes" json:"preferred_max_bytes,omitempty"`
}

func (m *BatchSize) Reset()                    { *m = BatchSize{} }
func (m *BatchSize) String() string            { return proto.CompactTextString(m) }
func (*BatchSize) ProtoMessage()               {}
func (*BatchSize) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *BatchSize) GetMaxMessageCount() uint32 {
	if m != nil {
		return m.MaxMessageCount
	}
	return 0
}

func (m *BatchSize) GetAbsoluteMaxBytes() uint32 {
	if m != nil {
		return m.AbsoluteMaxBytes
	}
	return 0
}

func (m *BatchSize) GetPreferredMaxBytes() uint32 {
	if m != nil {
		return m.PreferredMaxBytes
	}
	return 0
}

type BatchTimeout struct {
	// Any duration string parseable by ParseDuration():
	// https://golang.org/pkg/time/#ParseDuration
	Timeout string `protobuf:"bytes,1,opt,name=timeout" json:"timeout,omitempty"`
}

func (m *BatchTimeout) Reset()                    { *m = BatchTimeout{} }
func (m *BatchTimeout) String() string            { return proto.CompactTextString(m) }
func (*BatchTimeout) ProtoMessage()               {}
func (*BatchTimeout) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *BatchTimeout) GetTimeout() string {
	if m != nil {
		return m.Timeout
	}
	return ""
}

// Carries a list of bootstrap brokers, i.e. this is not the exclusive set of
// brokers an ordering service
type KafkaBrokers struct {
	// Each broker here should be identified using the (IP|host):port notation,
	// e.g. 127.0.0.1:7050, or localhost:7050 are valid entries
	Brokers []string `protobuf:"bytes,1,rep,name=brokers" json:"brokers,omitempty"`
}

func (m *KafkaBrokers) Reset()                    { *m = KafkaBrokers{} }
func (m *KafkaBrokers) String() string            { return proto.CompactTextString(m) }
func (*KafkaBrokers) ProtoMessage()               {}
func (*KafkaBrokers) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *KafkaBrokers) GetBrokers() []string {
	if m != nil {
		return m.Brokers
	}
	return nil
}

// ChannelRestrictions is the mssage which conveys restrictions on channel creation for an orderer
type ChannelRestrictions struct {
	MaxCount uint64 `protobuf:"varint,1,opt,name=max_count,json=maxCount" json:"max_count,omitempty"`
}

func (m *ChannelRestrictions) Reset()                    { *m = ChannelRestrictions{} }
func (m *ChannelRestrictions) String() string            { return proto.CompactTextString(m) }
func (*ChannelRestrictions) ProtoMessage()               {}
func (*ChannelRestrictions) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *ChannelRestrictions) GetMaxCount() uint64 {
	if m != nil {
		return m.MaxCount
	}
	return 0
}

func init() {
	proto.RegisterType((*ConsensusType)(nil), "orderer.ConsensusType")
	proto.RegisterType((*BatchSize)(nil), "orderer.BatchSize")
	proto.RegisterType((*BatchTimeout)(nil), "orderer.BatchTimeout")
	proto.RegisterType((*KafkaBrokers)(nil), "orderer.KafkaBrokers")
	proto.RegisterType((*ChannelRestrictions)(nil), "orderer.ChannelRestrictions")
}

func init() { proto.RegisterFile("orderer/configuration.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 317 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x90, 0x41, 0x4b, 0xc3, 0x40,
	0x14, 0x84, 0x89, 0x2d, 0xd6, 0x2e, 0x16, 0xed, 0xf6, 0x12, 0xe8, 0xa5, 0x44, 0x84, 0x52, 0x24,
	0x01, 0xfd, 0x07, 0xe9, 0x51, 0x7a, 0x49, 0x7b, 0xf2, 0x52, 0x36, 0xe9, 0x4b, 0xb2, 0xb4, 0xd9,
	0x17, 0xde, 0x6e, 0x30, 0xf1, 0x7f, 0xf8, 0x7f, 0x65, 0x37, 0xa9, 0x7a, 0x7b, 0x33, 0xf3, 0x2d,
	0xcc, 0x0e, 0x5b, 0x22, 0x9d, 0x80, 0x80, 0xa2, 0x0c, 0x55, 0x2e, 0x8b, 0x86, 0x84, 0x91, 0xa8,
	0xc2, 0x9a, 0xd0, 0x20, 0x9f, 0x0c, 0x61, 0xf0, 0xc4, 0x66, 0x5b, 0x54, 0x1a, 0x94, 0x6e, 0xf4,
	0xa1, 0xab, 0x81, 0x73, 0x36, 0x36, 0x5d, 0x0d, 0xbe, 0xb7, 0xf2, 0xd6, 0xd3, 0xc4, 0xdd, 0xc1,
	0xb7, 0xc7, 0xa6, 0xb1, 0x30, 0x59, 0xb9, 0x97, 0x5f, 0xc0, 0x37, 0x6c, 0x5e, 0x89, 0xf6, 0x58,
	0x81, 0xd6, 0xa2, 0x80, 0x63, 0x86, 0x8d, 0x32, 0x0e, 0x9f, 0x25, 0x0f, 0x95, 0x68, 0x77, 0xbd,
	0xbf, 0xb5, 0x36, 0x7f, 0x61, 0x5c, 0xa4, 0x1a, 0x2f, 0x8d, 0x81, 0xa3, 0x7d, 0x94, 0x76, 0x06,
	0xb4, 0x7f, 0xe3, 0xe0, 0xc7, 0x6b, 0xb2, 0x13, 0x6d, 0x6c, 0x7d, 0x1e, 0xb2, 0x45, 0x4d, 0x90,
	0x03, 0x11, 0x9c, 0xfe, 0xe1, 0x23, 0x87, 0xcf, 0x7f, 0xa3, 0x2b, 0x1f, 0xac, 0xd9, 0xbd, 0xab,
	0x75, 0x90, 0x15, 0x60, 0x63, 0xb8, 0xcf, 0x26, 0xa6, 0x3f, 0x87, 0xfa, 0x57, 0x69, 0xc9, 0x77,
	0x91, 0x9f, 0x45, 0x4c, 0x78, 0x06, 0xd2, 0x96, 0x4c, 0xfb, 0xd3, 0xf7, 0x56, 0x23, 0x4b, 0x0e,
	0x32, 0x78, 0x65, 0x8b, 0x6d, 0x29, 0x94, 0x82, 0x4b, 0x02, 0xda, 0x90, 0xcc, 0xec, 0x6a, 0x9a,
	0x2f, 0xd9, 0xd4, 0x16, 0xfa, 0xfb, 0xec, 0x38, 0xb9, 0xab, 0x44, 0xeb, 0x7e, 0x19, 0xef, 0xd9,
	0x33, 0x52, 0x11, 0x96, 0x5d, 0x0d, 0x74, 0x81, 0x53, 0x01, 0x14, 0xe6, 0x22, 0x25, 0x99, 0xf5,
	0x6b, 0xeb, 0x70, 0x58, 0xfb, 0x63, 0x53, 0x48, 0x53, 0x36, 0x69, 0x98, 0x61, 0x15, 0x7d, 0x96,
	0xc2, 0x48, 0x8d, 0x58, 0x47, 0x3d, 0x1b, 0xf5, 0x6c, 0x34, 0xb0, 0xe9, 0xad, 0xd3, 0x6f, 0x3f,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xc9, 0x6a, 0xd0, 0x0c, 0xc8, 0x01, 0x00, 0x00,
}
